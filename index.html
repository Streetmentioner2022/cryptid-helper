<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>NAFO • Style Prompt Generator</title>

  <style>
    :root{
      --bg: #07090d;
      --panel: rgba(255,255,255,.04);
      --border: rgba(255,255,255,.12);
      --border2: rgba(255,255,255,.18);
      --text: rgba(255,255,255,.92);
      --muted: rgba(255,255,255,.72);
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
      --sans: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      --radius: 16px;
    }

    *{ box-sizing: border-box; }
    html, body { height: 100%; }
    body{
      margin: 0;
      font-family: var(--sans);
      background: radial-gradient(1200px 600px at 20% -10%, rgba(255,255,255,.06), transparent 55%),
                  radial-gradient(900px 500px at 90% 10%, rgba(255,255,255,.05), transparent 60%),
                  var(--bg);
      color: var(--text);
      overflow-x: hidden;
    }

    .scanlines::before{
      content:"";
      position: fixed;
      inset: 0;
      pointer-events: none;
      background:
        repeating-linear-gradient(
          to bottom,
          rgba(255,255,255,.03) 0px,
          rgba(255,255,255,.03) 1px,
          rgba(0,0,0,0) 2px,
          rgba(0,0,0,0) 4px
        );
      mix-blend-mode: overlay;
      opacity: .35;
      z-index: 40;
    }
    .scanlines::after{
      content:"";
      position: fixed;
      inset: 0;
      pointer-events: none;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='180' height='180'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='.9' numOctaves='2' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='180' height='180' filter='url(%23n)' opacity='.22'/%3E%3C/svg%3E");
      opacity: .06;
      z-index: 41;
    }

    .wrap{ max-width: 1100px; margin: 0 auto; padding: 18px 16px 40px; }

    .classbar{
      display: flex; justify-content: space-between; align-items: center; gap: 10px;
      border: 1px solid var(--border);
      background: rgba(0,0,0,.28);
      border-radius: var(--radius);
      padding: 10px 12px;
      margin-bottom: 14px;
      backdrop-filter: blur(6px);
    }
    .classbar span{
      letter-spacing: .14em;
      font-size: 12px;
      text-transform: uppercase;
      color: var(--muted);
    }
    .mono{ font-family: var(--mono); }

    .titleblock{
      border: 1px solid var(--border);
      background: rgba(0,0,0,.22);
      border-radius: var(--radius);
      padding: 14px 14px;
      margin-bottom: 14px;
      backdrop-filter: blur(6px);
    }
    .titleblock h1{
      margin: 0 0 6px;
      font-size: 18px;
      letter-spacing: .06em;
      text-transform: uppercase;
    }
    .titleblock p{ margin: 0; color: var(--muted); line-height: 1.45; }

    .panel{
      border: 1px solid var(--border);
      background: var(--panel);
      border-radius: var(--radius);
      padding: 16px;
      backdrop-filter: blur(6px);
    }
    .panel-title{
      margin: 0 0 6px;
      font-size: 16px;
      letter-spacing: .06em;
      text-transform: uppercase;
    }
    .panel-subtitle{ margin: 0 0 14px; color: var(--muted); line-height: 1.45; }

    .grid{ display: grid; grid-template-columns: 1fr 1fr; gap: 14px; }
    @media (max-width: 900px){ .grid{ grid-template-columns: 1fr; } }

    .controls{ display: grid; gap: 12px; }
    .field{ display: grid; gap: 6px; }
    .label{
      font-size: 12px;
      letter-spacing: .14em;
      opacity: .9;
      text-transform: uppercase;
    }
    .select, .textarea, .input{
      width: 100%;
      border-radius: 12px;
      border: 1px solid var(--border);
      padding: 10px 12px;
      background: rgba(0,0,0,.35);
      color: var(--text);
      outline: none;
    }
    .select:focus, .textarea:focus, .input:focus{
      border-color: rgba(255,255,255,.22);
      box-shadow: 0 0 0 3px rgba(255,255,255,.05);
    }

    .row{ display: flex; gap: 10px; margin-top: 10px; flex-wrap: wrap; }
    .btn{
      border-radius: 12px;
      border: 1px solid var(--border2);
      background: rgba(255,255,255,.06);
      padding: 10px 12px;
      cursor: pointer;
      color: var(--text);
      letter-spacing: .08em;
      text-transform: uppercase;
      font-size: 12px;
    }
    .btn:hover{ background: rgba(255,255,255,.10); }
    .btn.ghost{ background: transparent; opacity: .9; }

    .hint{ margin: 10px 0 0; color: var(--muted); min-height: 18px; }
    .divider{ height: 1px; background: rgba(255,255,255,.08); margin: 14px 0; }
    .footer{
      margin-top: 14px;
      color: var(--muted);
      font-size: 12px;
      letter-spacing: .08em;
      text-transform: uppercase;
    }

    .pill{
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 8px 10px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: rgba(0,0,0,.25);
      color: var(--muted);
      font-size: 12px;
      letter-spacing: .08em;
      text-transform: uppercase;
      margin-top: 10px;
    }

    .checkrow{
      display: flex;
      align-items: center;
      gap: 10px;
      border: 1px solid var(--border);
      background: rgba(0,0,0,.25);
      padding: 10px 12px;
      border-radius: 12px;
    }
    .checkrow input{ transform: scale(1.15); }
    .checkrow .labeltext{
      letter-spacing: .14em;
      text-transform: uppercase;
      font-size: 12px;
      opacity: .9;
    }
    .checkrow .sub{
      margin-left: auto;
      font-size: 12px;
      opacity: .7;
    }
  </style>
</head>

<body class="scanlines">
  <div class="wrap">
    <div class="classbar">
      <span>CLASSIFIED • FIELD REPORT</span>
      <span class="mono">ARCHIVE NODE 32</span>
    </div>

    <div class="titleblock">
      <h1 class="mono">National Anomaly Field Office</h1>
      <p class="mono">Style Prompt Generator • officially denied</p>
    </div>

    <section class="panel" id="prompt-generator">
      <h2 class="panel-title mono">Prompt Composer</h2>
      <p class="panel-subtitle mono">Evidence-first ordering • creature often absent/obscured • MidJourney V7</p>

      <div class="grid">
        <div class="controls" id="controls"></div>

        <div class="output">
          <label class="label mono" for="finalPrompt">FINAL PROMPT</label>
          <textarea id="finalPrompt" class="textarea mono" rows="12" readonly></textarea>

          <div class="row">
            <button class="btn mono" id="copyBtn" type="button">Copy</button>
            <button class="btn ghost mono" id="resetBtn" type="button">Reset</button>
          </div>

          <p class="hint mono" id="copyHint" aria-live="polite"></p>
          <div class="pill mono" id="statusPill">MJ Params: —</div>

          <div class="divider"></div>
          <div class="footer mono">NAFO // INTERNAL TOOLING // DO NOT DISTRIBUTE</div>
        </div>
      </div>
    </section>
  </div>

  <script>
    (() => {
      const DATA = {
        folkloreIntensity: [
          { value: "0", label: "0 — Mundane (realism)" },
          { value: "1", label: "1 — Local Legend" },
          { value: "2", label: "2 — Unsettling" },
          { value: "3", label: "3 — Mythic" }
        ],
        credibility: [
          { value: "believable", label: "Believable (documentary)" },
          { value: "questionable", label: "Questionable (ambiguous)" },
          { value: "fabricated", label: "Fabricated (staged)" }
        ],

        // NEW: evidence-first subject control
        evidence: [
          { value: "none", label: "None — no subject visible" },
          { value: "trace", label: "Trace — footprints / damage / disturbed brush" },
          { value: "implied", label: "Implied — shadow / reflection / shape in fog" },
          { value: "distant", label: "Distant — tiny silhouette on horizon" },
          { value: "partial", label: "Partial — obscured / frame cut-off" },
          { value: "clear", label: "Clear — full view (rare)" }
        ],

        cameras: [
          { value: "35mm", label: "35mm film photo" },
          { value: "polaroid", label: "Polaroid" },
          { value: "cctv", label: "CCTV still" },
          { value: "handheld_video", label: "Handheld camcorder frame" },
          { value: "thermal", label: "Thermal imaging" },
          { value: "night_vision", label: "Night vision" }
        ],

        locations: [
          { value: "pine_forest", label: "Pine forest" },
          { value: "abandoned_mill", label: "Abandoned mill" },
          { value: "rural_road", label: "Rural road" },
          { value: "swamp", label: "Swamp" },
          { value: "coastal_cliffs", label: "Coastal cliffs" },
          { value: "suburban_woods", label: "Suburban treeline" },
          { value: "derelict_town", label: "Derelict town" }
        ],

        atmospheres: [
          { value: "fog", label: "Fog" },
          { value: "thunderstorm", label: "Thunderstorm" },
          { value: "heavy_rain", label: "Heavy rain" },
          { value: "snow", label: "Snow" },
          { value: "low_mist", label: "Low ground mist" },
          { value: "moonless_night", label: "Moonless night" },
          { value: "sodium_vapor", label: "Sodium-vapor streetlight haze" }
        ],

        classifications: [
          { value: "cryptid", label: "Cryptid" },
          { value: "fae", label: "Fae" },
          { value: "apparition", label: "Apparition" },
          { value: "aberration", label: "Aberration" },
          { value: "entity", label: "Unknown Entity" },
          { value: "artifact", label: "Anomalous Artifact" }
        ],

        creatures: {
          cryptid: [
            { value: "mothman", label: "Mothman" },
            { value: "jersey_devil", label: "Jersey Devil" },
            { value: "bigfoot", label: "Bigfoot / Sasquatch" },
            { value: "chupacabra", label: "Chupacabra" },
            { value: "dover_demon", label: "Dover Demon" },
            { value: "flatwoods", label: "Flatwoods Monster" }
          ],
          fae: [
            { value: "wild_hunt", label: "The Wild Hunt" },
            { value: "leprechaun", label: "Leprechaun" },
            { value: "selkie", label: "Selkie" },
            { value: "redcap", label: "Redcap" },
            { value: "brownie", label: "Brownie" },
            { value: "banshee", label: "Banshee" }
          ],
          apparition: [
            { value: "woman_in_white", label: "Woman in White" },
            { value: "black_dog", label: "Black Dog" },
            { value: "headless_rider", label: "Headless Rider" },
            { value: "poltergeist", label: "Poltergeist" },
            { value: "shadow_person", label: "Shadow Person" }
          ],
          aberration: [
            { value: "fleshgait", label: "Fleshgait" },
            { value: "mimic", label: "Mimic" },
            { value: "crawler", label: "Pale Crawler" },
            { value: "things_that_knock", label: "Things That Knock" }
          ],
          entity: [
            { value: "unknown_biologic", label: "Unknown Biologic" },
            { value: "unknown_humanoid", label: "Unknown Humanoid" },
            { value: "unknown_aerial", label: "Unknown Aerial" },
            { value: "unknown_aquatic", label: "Unknown Aquatic" }
          ],
          artifact: [
            { value: "cursed_relic", label: "Cursed Relic" },
            { value: "impossible_device", label: "Impossible Device" },
            { value: "forbidden_text", label: "Forbidden Text" },
            { value: "anomalous_signal", label: "Anomalous Signal Source" }
          ]
        },

        variants: {
          mothman: [
            { value: "red_eyes", label: "Red-Eyed Silhouette" },
            { value: "ash_wings", label: "Ash-Dusted Wings" },
            { value: "bridge_omen", label: "Bridge Omen" }
          ],
          jersey_devil: [
            { value: "pine_barrens", label: "Pine Barrens Stalker" },
            { value: "hoofprints", label: "Hoofprint Trail" }
          ],
          wild_hunt: [
            { value: "horned_riders", label: "Horned Riders" },
            { value: "hounds", label: "Black Hounds" },
            { value: "winter_procession", label: "Winter Procession" }
          ]
        },

        aspectRatios: [
          { value: "1:1", label: "1:1 (Square)" },
          { value: "3:2", label: "3:2 (35mm photo)" },
          { value: "2:3", label: "2:3 (Portrait photo)" },
          { value: "4:3", label: "4:3 (Old video)" },
          { value: "16:9", label: "16:9 (Widescreen)" },
          { value: "9:16", label: "9:16 (Vertical)" },
          { value: "21:9", label: "21:9 (Ultra-wide)" }
        ],

        quality: [
          { value: "1", label: "1 (Default)" },
          { value: "2", label: "2 (More detail / more GPU)" },
          { value: "4", label: "4 (Max detail / more GPU)" }
        ]
      };

      const DEFAULT_STYLE_BASE = [
        "found footage documentary photograph",
        "accidental folklore documentation",
        "imperfect framing, unsteady composition",
        "natural low light exposure",
        "no cinematic polish"
      ];

      const CAMERA_PROFILES = {
        "35mm": [
          "found footage documentary photograph",
          "accidental folklore documentation",
          "authentic 35mm film photograph",
          "visible analog film grain",
          "slight underexposure, imperfect focus",
          "imperfect framing, candid moment",
          "no cinematic polish"
        ],
        "polaroid": [
          "found footage documentary photograph",
          "accidental folklore documentation",
          "polaroid instant photo",
          "soft focus, uneven exposure",
          "chemical artifacts, faded color cast",
          "handheld snapshot composition",
          "no cinematic polish"
        ],
        "cctv": [
          "surveillance camera still",
          "paranormal incident documentation",
          "fixed wide angle, unflattering perspective",
          "low resolution, compression artifacts",
          "timestamped security footage aesthetic",
          "harsh overhead lighting or dim ambient light"
        ],
        "handheld_video": [
          "found footage camcorder frame",
          "accidental folklore documentation",
          "handheld documentary video still",
          "motion blur, rolling shutter artifacts",
          "imperfect focus, low light noise",
          "no cinematic polish"
        ],
        "thermal": [
          "thermal imaging still",
          "incident documentation",
          "heat signature contrast, sensor noise",
          "low detail edges, utilitarian capture",
          "unsettling ambiguity, non-cinematic"
        ],
        "night_vision": [
          "night vision footage still",
          "incident documentation",
          "infrared glow, high noise",
          "crushed blacks, blown highlights",
          "unsteady handheld framing",
          "non-cinematic, purely observational"
        ]
      };

      const FOLKLORE_MAP = {
        "0": { s: 50,  w: 0   },
        "1": { s: 100, w: 40  },
        "2": { s: 200, w: 120 },
        "3": { s: 350, w: 300 }
      };

      const CREDIBILITY_MAP = {
        believable:   { chaos: 5,  tag: "documentary authenticity, plausible event" },
        questionable: { chaos: 15, tag: "ambiguous evidence, unclear subject" },
        fabricated:   { chaos: 30, tag: "possible staged footage, uncanny presentation" }
      };

      const EVIDENCE_TAGS = {
        none:    "no subject visible, empty frame, unsettling absence",
        trace:   "only traces visible, disturbed brush, footprints, broken branches",
        implied: "implied presence, shadow in fog, reflection anomaly, half-seen shape",
        distant: "distant silhouette on horizon, barely perceptible figure",
        partial: "partial glimpse, obscured by trees, frame cut-off, motion blur",
        clear:   "clear subject visibility, full figure present"
      };

      const state = {
        folklore: "1",
        credibility: "questionable",

        camera: "",
        location: "",
        atmosphere: "",
        evidence: "distant",

        classification: "",
        creature: "",
        variant: "",

        aspectRatio: "16:9",
        chaos: "10",
        raw: false,
        quality: "1",

        chaosLockedByUser: false
      };

      const controls = document.getElementById("controls");
      const finalPrompt = document.getElementById("finalPrompt");
      const copyBtn = document.getElementById("copyBtn");
      const resetBtn = document.getElementById("resetBtn");
      const copyHint = document.getElementById("copyHint");
      const statusPill = document.getElementById("statusPill");

      function el(tag, attrs = {}, children = []) {
        const node = document.createElement(tag);
        Object.entries(attrs).forEach(([k, v]) => {
          if (k === "class") node.className = v;
          else if (k === "for") node.htmlFor = v;
          else if (k === "checked") node.checked = !!v;
          else node.setAttribute(k, v);
        });
        children.forEach(c => node.appendChild(typeof c === "string" ? document.createTextNode(c) : c));
        return node;
      }

      function makeSelect({ id, label, options, placeholder = "Select…", value, onChange }) {
        const select = el("select", { id, class: "select mono" });
        select.appendChild(el("option", { value: "" }, [placeholder]));
        options.forEach(opt => select.appendChild(el("option", { value: opt.value }, [opt.label])));
        select.value = value || "";
        select.addEventListener("change", (e) => onChange(e.target.value));
        return el("div", { class: "field" }, [
          el("label", { class: "label mono", for: id }, [label]),
          select
        ]);
      }

      function makeInput({ id, label, value, placeholder = "", onInput, type = "number", min, max, step }) {
        const attrs = { id, class: "input mono", value: value ?? "", placeholder, type };
        if (min !== undefined) attrs.min = String(min);
        if (max !== undefined) attrs.max = String(max);
        if (step !== undefined) attrs.step = String(step);
        const input = el("input", attrs);
        input.addEventListener("input", (e) => onInput(e.target.value));
        return el("div", { class: "field" }, [
          el("label", { class: "label mono", for: id }, [label]),
          input
        ]);
      }

      function makeCheckboxRow({ id, label, checked, hint, onChange }) {
        const box = el("input", { id, type: "checkbox", checked });
        box.addEventListener("change", (e) => onChange(e.target.checked));
        return el("div", { class: "checkrow" }, [
          box,
          el("div", { class: "labeltext mono" }, [label]),
          el("div", { class: "sub mono" }, [hint || ""])
        ]);
      }

      function clampInt(v, min, max, fallback) {
        const n = parseInt(v, 10);
        if (Number.isNaN(n)) return fallback;
        return Math.min(max, Math.max(min, n));
      }

      function clearBelow(keys) { keys.forEach(k => state[k] = ""); }

      function labelFor(list, value) {
        const item = (list || []).find(x => x.value === value);
        return item ? item.label : "";
      }

      function applyDials() {
        const f = FOLKLORE_MAP[state.folklore] || FOLKLORE_MAP["1"];
        state._stylize = f.s;
        state._weird = f.w;

        const c = CREDIBILITY_MAP[state.credibility] || CREDIBILITY_MAP.questionable;
        state._credTag = c.tag;

        if (!state.chaosLockedByUser) state.chaos = String(c.chaos);
      }

      function renderControls() {
        controls.innerHTML = "";

        // 1) Dials
        controls.appendChild(makeSelect({
          id: "folkloreSelect",
          label: "FOLKLORE INTENSITY",
          options: DATA.folkloreIntensity,
          placeholder: "Select intensity…",
          value: state.folklore,
          onChange: (val) => { state.folklore = val || "1"; renderPrompt(); }
        }));

        controls.appendChild(makeSelect({
          id: "credSelect",
          label: "CREDIBILITY",
          options: DATA.credibility,
          placeholder: "Select credibility…",
          value: state.credibility,
          onChange: (val) => { state.credibility = val || "questionable"; renderPrompt(); }
        }));

        // 2) Capture Type early
        controls.appendChild(makeSelect({
          id: "cameraSelect",
          label: "CAPTURE TYPE (OVERRIDES STYLE)",
          options: DATA.cameras,
          placeholder: "Select capture type…",
          value: state.camera,
          onChange: (val) => { state.camera = val; renderPrompt(); }
        }));

        // 3) Location + Atmosphere
        controls.appendChild(makeSelect({
          id: "locationSelect",
          label: "LOCATION",
          options: DATA.locations,
          placeholder: "Select location…",
          value: state.location,
          onChange: (val) => { state.location = val; renderPrompt(); }
        }));

        controls.appendChild(makeSelect({
          id: "atmosphereSelect",
          label: "ATMOSPHERE",
          options: DATA.atmospheres,
          placeholder: "Select atmosphere…",
          value: state.atmosphere,
          onChange: (val) => { state.atmosphere = val; renderPrompt(); }
        }));

        // 4) Evidence level (key for your note)
        controls.appendChild(makeSelect({
          id: "evidenceSelect",
          label: "EVIDENCE LEVEL",
          options: DATA.evidence,
          placeholder: "Select evidence…",
          value: state.evidence,
          onChange: (val) => { state.evidence = val || "distant"; renderControls(); renderPrompt(); }
        }));

        // 5) Creature as optional (only show if evidence is not "none" or "trace")
        const showCreature = (state.evidence !== "none" && state.evidence !== "trace");
        if (showCreature) {
          controls.appendChild(makeSelect({
            id: "classificationSelect",
            label: "CLASSIFICATION (OPTIONAL)",
            options: DATA.classifications,
            placeholder: "Select classification…",
            value: state.classification,
            onChange: (val) => {
              state.classification = val;
              clearBelow(["creature", "variant"]);
              renderControls();
              renderPrompt();
            }
          }));

          if (state.classification) {
            controls.appendChild(makeSelect({
              id: "creatureSelect",
              label: "CREATURE (OPTIONAL)",
              options: DATA.creatures[state.classification] || [],
              placeholder: "Select creature…",
              value: state.creature,
              onChange: (val) => {
                state.creature = val;
                clearBelow(["variant"]);
                renderControls();
                renderPrompt();
              }
            }));
          }

          const variantOptions = state.creature ? (DATA.variants[state.creature] || []) : [];
          if (state.creature && variantOptions.length) {
            controls.appendChild(makeSelect({
              id: "variantSelect",
              label: "VARIANT (OPTIONAL)",
              options: variantOptions,
              placeholder: "Select variant…",
              value: state.variant,
              onChange: (val) => { state.variant = val; renderPrompt(); }
            }));
          }
        } else {
          // if evidence implies no creature selection, clear them
          state.classification = "";
          state.creature = "";
          state.variant = "";
        }

        // 6) MJ Params
        controls.appendChild(makeSelect({
          id: "aspectRatioSelect",
          label: "ASPECT RATIO (MJ --ar)",
          options: DATA.aspectRatios,
          placeholder: "Select aspect ratio…",
          value: state.aspectRatio,
          onChange: (val) => { state.aspectRatio = val || "16:9"; renderPrompt(); }
        }));

        controls.appendChild(makeInput({
          id: "chaosInput",
          label: "CHAOS (MJ --chaos 0–100)",
          value: state.chaos,
          placeholder: "0–100",
          min: 0, max: 100, step: 1,
          onInput: (val) => {
            state.chaosLockedByUser = true;
            state.chaos = String(clampInt(val, 0, 100, 10));
            renderPrompt();
          }
        }));

        controls.appendChild(makeSelect({
          id: "qualitySelect",
          label: "QUALITY (MJ --q)",
          options: DATA.quality,
          placeholder: "Select quality…",
          value: state.quality,
          onChange: (val) => { state.quality = val || "1"; renderPrompt(); }
        }));

        controls.appendChild(makeCheckboxRow({
          id: "rawToggle",
          label: "RAW MODE",
          checked: state.raw,
          hint: "--raw",
          onChange: (checked) => { state.raw = checked; renderPrompt(); }
        }));
      }

      function renderPrompt() {
        applyDials();

        const parts = [];

        const base = (state.camera && CAMERA_PROFILES[state.camera])
          ? CAMERA_PROFILES[state.camera]
          : DEFAULT_STYLE_BASE;

        base.forEach(s => parts.push(s));

        if (state._credTag) parts.push(state._credTag);

        // Evidence language comes BEFORE creature
        if (state.evidence) parts.push(EVIDENCE_TAGS[state.evidence] || "");

        if (state.location) parts.push(`location: ${labelFor(DATA.locations, state.location)}`);
        if (state.atmosphere) parts.push(`atmosphere: ${labelFor(DATA.atmospheres, state.atmosphere)}`);

        // Creature is conditional:
        // - clear: include subject explicitly (if chosen)
        // - distant/partial/implied: only mention if chosen, but keep it vague
        const evidence = state.evidence;

        if (state.creature && state.classification) {
          const cList = DATA.creatures[state.classification] || [];
          const creatureLabel = labelFor(cList, state.creature);

          if (evidence === "clear") {
            parts.push(`subject: ${creatureLabel}`);
            if (state.variant) parts.push(`variant: ${labelFor(DATA.variants[state.creature], state.variant)}`);
          } else if (evidence === "distant") {
            parts.push(`possible distant figure: ${creatureLabel}`);
          } else if (evidence === "partial") {
            parts.push(`partial glimpse suggests: ${creatureLabel}`);
          } else if (evidence === "implied") {
            parts.push(`implied presence suggests: ${creatureLabel}`);
          }
        }

        parts.push("subtle scanlines, archival wear, restrained horror");

        const descriptive = parts.filter(Boolean).join(", ");

        const params = [];
        params.push(`--ar ${state.aspectRatio || "16:9"}`);

        const chaos = clampInt(state.chaos, 0, 100, 10);
        params.push(`--chaos ${chaos}`);

        if (state.raw) params.push(`--raw`);

        // dials always included (core instrument)
        params.push(`--s ${state._stylize}`);
        params.push(`--w ${state._weird}`);

        const q = (state.quality === "2" || state.quality === "4") ? state.quality : "1";
        if (q !== "1") params.push(`--q ${q}`);

        finalPrompt.value = descriptive + " " + params.join(" ");
        statusPill.textContent = "MJ Params: " + params.join(" ");
      }

      async function copyPrompt() {
        copyHint.textContent = "";
        const text = finalPrompt.value;
        try {
          await navigator.clipboard.writeText(text);
          copyHint.textContent = "Copied to clipboard.";
        } catch (e) {
          finalPrompt.focus();
          finalPrompt.select();
          document.execCommand("copy");
          copyHint.textContent = "Copied (fallback).";
        }
        setTimeout(() => (copyHint.textContent = ""), 1400);
      }

      function resetAll() {
        state.folklore = "1";
        state.credibility = "questionable";
        state.camera = "";
        state.location = "";
        state.atmosphere = "";
        state.evidence = "distant";
        state.classification = "";
        state.creature = "";
        state.variant = "";
        state.aspectRatio = "16:9";
        state.chaos = "10";
        state.raw = false;
        state.quality = "1";
        state.chaosLockedByUser = false;
        copyHint.textContent = "";
        renderControls();
        renderPrompt();
      }

      copyBtn.addEventListener("click", copyPrompt);
      resetBtn.addEventListener("click", resetAll);

      renderControls();
      renderPrompt();
    })();
  </script>
</body>
</html>
