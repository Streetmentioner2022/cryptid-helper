<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>NAFO • Style Prompt Generator</title>

  <style>
    :root{
      --bg: #07090d;
      --panel: rgba(255,255,255,.04);
      --border: rgba(255,255,255,.12);
      --border2: rgba(255,255,255,.18);
      --text: rgba(255,255,255,.92);
      --muted: rgba(255,255,255,.72);
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
      --sans: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      --radius: 16px;
    }
    *{ box-sizing: border-box; }
    html, body { height: 100%; }
    body{
      margin: 0;
      font-family: var(--sans);
      background: radial-gradient(1200px 600px at 20% -10%, rgba(255,255,255,.06), transparent 55%),
                  radial-gradient(900px 500px at 90% 10%, rgba(255,255,255,.05), transparent 60%),
                  var(--bg);
      color: var(--text);
      overflow-x: hidden;
    }

    /* Subtle CRT scanlines + noise */
    .scanlines::before{
      content:"";
      position: fixed;
      inset: 0;
      pointer-events: none;
      background:
        repeating-linear-gradient(
          to bottom,
          rgba(255,255,255,.03) 0px,
          rgba(255,255,255,.03) 1px,
          rgba(0,0,0,0) 2px,
          rgba(0,0,0,0) 4px
        );
      mix-blend-mode: overlay;
      opacity: .35;
      z-index: 40;
    }
    .scanlines::after{
      content:"";
      position: fixed;
      inset: 0;
      pointer-events: none;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='180' height='180'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='.9' numOctaves='2' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='180' height='180' filter='url(%23n)' opacity='.22'/%3E%3C/svg%3E");
      opacity: .06;
      z-index: 41;
    }

    .wrap{ max-width: 1100px; margin: 0 auto; padding: 18px 16px 40px; }
    .classbar{
      display: flex; justify-content: space-between; align-items: center; gap: 10px;
      border: 1px solid var(--border);
      background: rgba(0,0,0,.28);
      border-radius: var(--radius);
      padding: 10px 12px;
      margin-bottom: 14px;
      backdrop-filter: blur(6px);
    }
    .classbar span{
      letter-spacing: .14em;
      font-size: 12px;
      text-transform: uppercase;
      color: var(--muted);
    }
    .mono{ font-family: var(--mono); }

    .titleblock{
      border: 1px solid var(--border);
      background: rgba(0,0,0,.22);
      border-radius: var(--radius);
      padding: 14px 14px;
      margin-bottom: 14px;
      backdrop-filter: blur(6px);
    }
    .titleblock h1{
      margin: 0 0 6px;
      font-size: 18px;
      letter-spacing: .06em;
      text-transform: uppercase;
    }
    .titleblock p{ margin: 0; color: var(--muted); line-height: 1.45; }

    .panel{
      border: 1px solid var(--border);
      background: var(--panel);
      border-radius: var(--radius);
      padding: 16px;
      backdrop-filter: blur(6px);
    }
    .panel-title{
      margin: 0 0 6px;
      font-size: 16px;
      letter-spacing: .06em;
      text-transform: uppercase;
    }
    .panel-subtitle{ margin: 0 0 14px; color: var(--muted); line-height: 1.45; }

    .grid{ display: grid; grid-template-columns: 1fr 1fr; gap: 14px; }
    @media (max-width: 900px){ .grid{ grid-template-columns: 1fr; } }

    .controls{ display: grid; gap: 12px; }
    .field{ display: grid; gap: 6px; }
    .label{
      font-size: 12px;
      letter-spacing: .14em;
      opacity: .9;
      text-transform: uppercase;
    }
    .select, .textarea, .input{
      width: 100%;
      border-radius: 12px;
      border: 1px solid var(--border);
      padding: 10px 12px;
      background: rgba(0,0,0,.35);
      color: var(--text);
      outline: none;
    }
    .select:focus, .textarea:focus, .input:focus{
      border-color: rgba(255,255,255,.22);
      box-shadow: 0 0 0 3px rgba(255,255,255,.05);
    }

    .row{ display: flex; gap: 10px; margin-top: 10px; flex-wrap: wrap; }
    .btn{
      border-radius: 12px;
      border: 1px solid var(--border2);
      background: rgba(255,255,255,.06);
      padding: 10px 12px;
      cursor: pointer;
      color: var(--text);
      letter-spacing: .08em;
      text-transform: uppercase;
      font-size: 12px;
    }
    .btn:hover{ background: rgba(255,255,255,.10); }
    .btn.ghost{ background: transparent; opacity: .9; }

    .hint{ margin: 10px 0 0; color: var(--muted); min-height: 18px; }
    .divider{ height: 1px; background: rgba(255,255,255,.08); margin: 14px 0; }
    .footer{
      margin-top: 14px;
      color: var(--muted);
      font-size: 12px;
      letter-spacing: .08em;
      text-transform: uppercase;
    }

    .pill{
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 8px 10px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: rgba(0,0,0,.25);
      color: var(--muted);
      font-size: 12px;
      letter-spacing: .08em;
      text-transform: uppercase;
      margin-top: 10px;
    }

    .checkrow{
      display: flex;
      align-items: center;
      gap: 10px;
      border: 1px solid var(--border);
      background: rgba(0,0,0,.25);
      padding: 10px 12px;
      border-radius: 12px;
    }
    .checkrow input{ transform: scale(1.15); }
    .checkrow .labeltext{
      letter-spacing: .14em;
      text-transform: uppercase;
      font-size: 12px;
      opacity: .9;
    }
    .checkrow .sub{
      margin-left: auto;
      font-size: 12px;
      opacity: .7;
    }
  </style>
</head>

<body class="scanlines">
  <div class="wrap">
    <div class="classbar">
      <span>CLASSIFIED • FIELD REPORT</span>
      <span class="mono">ARCHIVE NODE 32</span>
    </div>

    <div class="titleblock">
      <h1 class="mono">National Anomaly Field Office</h1>
      <p class="mono">Style Prompt Generator • officially denied</p>
    </div>

    <section class="panel" id="prompt-generator">
      <h2 class="panel-title mono">Prompt Composer</h2>
      <p class="panel-subtitle mono">Creature-first + higher variability • MidJourney V7</p>

      <div class="grid">
        <div class="controls" id="controls"></div>

        <div class="output">
          <label class="label mono" for="finalPrompt">FINAL PROMPT</label>
          <textarea id="finalPrompt" class="textarea mono" rows="12" readonly></textarea>

          <div class="row">
            <button class="btn mono" id="copyBtn" type="button">Copy</button>
            <button class="btn ghost mono" id="resetBtn" type="button">Reset</button>
            <button class="btn mono" id="randomBtn" type="button">Randomize Wording</button>
          </div>

          <p class="hint mono" id="copyHint" aria-live="polite"></p>
          <div class="pill mono" id="statusPill">MJ Params: —</div>

          <div class="divider"></div>
          <div class="footer mono">NAFO // INTERNAL TOOLING // DO NOT DISTRIBUTE</div>
        </div>
      </div>
    </section>
  </div>

  <script>
    (() => {
      // --------- small deterministic PRNG (so "Randomize" can vary wording) ----------
      function xfnv1a(str){
        let h = 2166136261 >>> 0;
        for (let i=0;i<str.length;i++){
          h ^= str.charCodeAt(i);
          h = Math.imul(h, 16777619);
        }
        return h >>> 0;
      }
      function mulberry32(a){
        return function(){
          let t = a += 0x6D2B79F5;
          t = Math.imul(t ^ (t >>> 15), t | 1);
          t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
          return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
        };
      }
      function pick(rng, arr){
        return arr[Math.floor(rng() * arr.length)];
      }
      function sampleN(rng, arr, n){
        const copy = arr.slice();
        for (let i = copy.length - 1; i > 0; i--) {
          const j = Math.floor(rng() * (i + 1));
          [copy[i], copy[j]] = [copy[j], copy[i]];
        }
        return copy.slice(0, Math.min(n, copy.length));
      }

      const DATA = {
        folkloreIntensity: [
          { value: "0", label: "0 — Mundane (realism)" },
          { value: "1", label: "1 — Local Legend" },
          { value: "2", label: "2 — Unsettling" },
          { value: "3", label: "3 — Mythic" }
        ],
        credibility: [
          { value: "believable", label: "Believable (documentary)" },
          { value: "questionable", label: "Questionable (ambiguous)" },
          { value: "fabricated", label: "Fabricated (staged)" }
        ],
        variation: [
          { value: "low", label: "Low (steady wording)" },
          { value: "med", label: "Medium (more variety)" },
          { value: "high", label: "High (lots of variety)" }
        ],
        visibility: [
          { value: "clear", label: "Clear (cryptid visible)" },
          { value: "partial", label: "Partial (obscured)" },
          { value: "distant", label: "Distant (far / horizon)" }
        ],

        cameras: [
          { value: "35mm", label: "35mm film photo" },
          { value: "polaroid", label: "Polaroid" },
          { value: "cctv", label: "CCTV still" },
          { value: "handheld_video", label: "Handheld camcorder frame" },
          { value: "thermal", label: "Thermal imaging" },
          { value: "night_vision", label: "Night vision" }
        ],
        locations: [
          { value: "pine_forest", label: "Pine forest" },
          { value: "abandoned_mill", label: "Abandoned mill" },
          { value: "rural_road", label: "Rural road" },
          { value: "swamp", label: "Swamp" },
          { value: "coastal_cliffs", label: "Coastal cliffs" },
          { value: "suburban_woods", label: "Suburban treeline" },
          { value: "derelict_town", label: "Derelict town" }
        ],
        atmospheres: [
          { value: "fog", label: "Fog" },
          { value: "thunderstorm", label: "Thunderstorm" },
          { value: "heavy_rain", label: "Heavy rain" },
          { value: "snow", label: "Snow" },
          { value: "low_mist", label: "Low ground mist" },
          { value: "moonless_night", label: "Moonless night" },
          { value: "sodium_vapor", label: "Sodium-vapor streetlight haze" }
        ],

        classifications: [
          { value: "cryptid", label: "Cryptid" },
          { value: "fae", label: "Fae" },
          { value: "apparition", label: "Apparition" },
          { value: "aberration", label: "Aberration" },
          { value: "entity", label: "Unknown Entity" },
          { value: "artifact", label: "Anomalous Artifact" }
        ],

        creatures: {
          cryptid: [
            { value: "mothman", label: "Mothman" },
            { value: "jersey_devil", label: "Jersey Devil" },
            { value: "bigfoot", label: "Bigfoot / Sasquatch" },
            { value: "chupacabra", label: "Chupacabra" },
            { value: "dover_demon", label: "Dover Demon" },
            { value: "flatwoods", label: "Flatwoods Monster" }
          ],
          fae: [
            { value: "wild_hunt", label: "The Wild Hunt" },
            { value: "leprechaun", label: "Leprechaun" },
            { value: "selkie", label: "Selkie" },
            { value: "redcap", label: "Redcap" },
            { value: "brownie", label: "Brownie" },
            { value: "banshee", label: "Banshee" }
          ],
          apparition: [
            { value: "woman_in_white", label: "Woman in White" },
            { value: "black_dog", label: "Black Dog" },
            { value: "headless_rider", label: "Headless Rider" },
            { value: "poltergeist", label: "Poltergeist" },
            { value: "shadow_person", label: "Shadow Person" }
          ],
          aberration: [
            { value: "fleshgait", label: "Fleshgait" },
            { value: "mimic", label: "Mimic" },
            { value: "crawler", label: "Pale Crawler" },
            { value: "things_that_knock", label: "Things That Knock" }
          ],
          entity: [
            { value: "unknown_biologic", label: "Unknown Biologic" },
            { value: "unknown_humanoid", label: "Unknown Humanoid" },
            { value: "unknown_aerial", label: "Unknown Aerial" },
            { value: "unknown_aquatic", label: "Unknown Aquatic" }
          ],
          artifact: [
            { value: "cursed_relic", label: "Cursed Relic" },
            { value: "impossible_device", label: "Impossible Device" },
            { value: "forbidden_text", label: "Forbidden Text" },
            { value: "anomalous_signal", label: "Anomalous Signal Source" }
          ]
        },

        variants: {
          mothman: [
            { value: "red_eyes", label: "Red-Eyed Silhouette" },
            { value: "ash_wings", label: "Ash-Dusted Wings" },
            { value: "bridge_omen", label: "Bridge Omen" }
          ],
          jersey_devil: [
            { value: "pine_barrens", label: "Pine Barrens Stalker" },
            { value: "hoofprints", label: "Hoofprint Trail" }
          ],
          wild_hunt: [
            { value: "horned_riders", label: "Horned Riders" },
            { value: "hounds", label: "Black Hounds" },
            { value: "winter_procession", label: "Winter Procession" }
          ]
        },

        aspectRatios: [
          { value: "1:1", label: "1:1 (Square)" },
          { value: "3:2", label: "3:2 (35mm photo)" },
          { value: "2:3", label: "2:3 (Portrait photo)" },
          { value: "4:3", label: "4:3 (Old video)" },
          { value: "16:9", label: "16:9 (Widescreen)" },
          { value: "9:16", label: "9:16 (Vertical)" },
          { value: "21:9", label: "21:9 (Ultra-wide)" }
        ],

        quality: [
          { value: "1", label: "1 (Default)" },
          { value: "2", label: "2 (More detail / more GPU)" },
          { value: "4", label: "4 (Max detail / more GPU)" }
        ]
      };

      // Camera overrides (still your option 1)
      const CAMERA_PROFILES = {
        "35mm": [
          "authentic 35mm film photograph",
          "visible analog film grain",
          "slight underexposure, imperfect focus"
        ],
        "polaroid": [
          "polaroid instant photo",
          "soft focus, uneven exposure",
          "chemical artifacts, faded color cast"
        ],
        "cctv": [
          "surveillance camera still",
          "low resolution, compression artifacts",
          "timestamped security footage aesthetic"
        ],
        "handheld_video": [
          "found footage camcorder frame",
          "motion blur, rolling shutter artifacts",
          "low light noise"
        ],
        "thermal": [
          "thermal imaging still",
          "heat signature contrast, sensor noise",
          "utilitarian capture"
        ],
        "night_vision": [
          "night vision footage still",
          "infrared glow, high noise",
          "crushed blacks, blown highlights"
        ]
      };

      // Dial mappings
      const FOLKLORE_MAP = {
        "0": { s: 50,  w: 0   },
        "1": { s: 100, w: 40  },
        "2": { s: 200, w: 120 },
        "3": { s: 350, w: 300 }
      };
      const CREDIBILITY_MAP = {
        believable:   { chaos: 5,  tag: "documentary authenticity, plausible event" },
        questionable: { chaos: 15, tag: "ambiguous evidence, unclear subject" },
        fabricated:   { chaos: 30, tag: "possible staged footage, uncanny presentation" }
      };

      // Wording banks (to reduce repetition)
      const OPENERS = [
        "found footage documentary photograph",
        "accidental field documentation photo",
        "amateur evidence photo",
        "unplanned encounter documentation",
        "candid incident photograph"
      ];
      const COMPOSITION = [
        "imperfect framing, unsteady composition",
        "crooked horizon, rushed framing",
        "candid composition, awkward angle",
        "off-center subject, accidental framing",
        "handheld shot, uneven composition"
      ];
      const TONE = [
        "restrained horror",
        "quiet dread",
        "uneasy stillness",
        "ominous calm",
        "unsettling realism"
      ];
      const ARTIFACTS = [
        "subtle scanlines",
        "archival wear",
        "minor lens grime",
        "dust specks on film",
        "edge vignetting",
        "light leak",
        "compression ringing"
      ];
      const MICRO_DETAILS = [
        "breath visible in cold air",
        "wind-blown branches",
        "distant streetlight glow",
        "wet ground reflections",
        "insect specks near lens",
        "mud on boots at frame edge",
        "flash glare off wet leaves",
        "camera strap shadow intruding"
      ];

      const VISIBILITY_TAGS = {
        clear:  ["clearly visible in frame", "full subject visible", "subject visible, not obscured"],
        partial:["partially obscured by trees", "partial glimpse, frame cut-off", "obscured by fog and motion blur"],
        distant:["tiny figure on the horizon", "distant silhouette far away", "small subject in wide shot"]
      };

      const state = {
        // Creature-first
        classification: "cryptid",
        creature: "",
        variant: "",

        // Dials
        folklore: "1",
        credibility: "questionable",
        variation: "med",
        visibility: "clear",

        // Scene/capture
        camera: "35mm",
        location: "",
        atmosphere: "",

        // MJ params
        aspectRatio: "16:9",
        chaos: "10",
        raw: false,
        quality: "1",

        chaosLockedByUser: false,
        seed: 1
      };

      const controls = document.getElementById("controls");
      const finalPrompt = document.getElementById("finalPrompt");
      const copyBtn = document.getElementById("copyBtn");
      const resetBtn = document.getElementById("resetBtn");
      const randomBtn = document.getElementById("randomBtn");
      const copyHint = document.getElementById("copyHint");
      const statusPill = document.getElementById("statusPill");

      function el(tag, attrs = {}, children = []) {
        const node = document.createElement(tag);
        Object.entries(attrs).forEach(([k, v]) => {
          if (k === "class") node.className = v;
          else if (k === "for") node.htmlFor = v;
          else if (k === "checked") node.checked = !!v;
          else node.setAttribute(k, v);
        });
        children.forEach(c => node.appendChild(typeof c === "string" ? document.createTextNode(c) : c));
        return node;
      }

      function makeSelect({ id, label, options, placeholder = "Select…", value, onChange }) {
        const select = el("select", { id, class: "select mono" });
        select.appendChild(el("option", { value: "" }, [placeholder]));
        options.forEach(opt => select.appendChild(el("option", { value: opt.value }, [opt.label])));
        select.value = value || "";
        select.addEventListener("change", (e) => onChange(e.target.value));
        return el("div", { class: "field" }, [
          el("label", { class: "label mono", for: id }, [label]),
          select
        ]);
      }

      function makeInput({ id, label, value, placeholder = "", onInput, type = "number", min, max, step }) {
        const attrs = { id, class: "input mono", value: value ?? "", placeholder, type };
        if (min !== undefined) attrs.min = String(min);
        if (max !== undefined) attrs.max = String(max);
        if (step !== undefined) attrs.step = String(step);
        const input = el("input", attrs);
        input.addEventListener("input", (e) => onInput(e.target.value));
        return el("div", { class: "field" }, [
          el("label", { class: "label mono", for: id }, [label]),
          input
        ]);
      }

      function makeCheckboxRow({ id, label, checked, hint, onChange }) {
        const box = el("input", { id, type: "checkbox", checked });
        box.addEventListener("change", (e) => onChange(e.target.checked));
        return el("div", { class: "checkrow" }, [
          box,
          el("div", { class: "labeltext mono" }, [label]),
          el("div", { class: "sub mono" }, [hint || ""])
        ]);
      }

      function clampInt(v, min, max, fallback) {
        const n = parseInt(v, 10);
        if (Number.isNaN(n)) return fallback;
        return Math.min(max, Math.max(min, n));
      }

      function clearBelow(keys) { keys.forEach(k => state[k] = ""); }

      function labelFor(list, value) {
        const item = (list || []).find(x => x.value === value);
        return item ? item.label : "";
      }

      function applyDials() {
        const f = FOLKLORE_MAP[state.folklore] || FOLKLORE_MAP["1"];
        state._stylize = f.s;
        state._weird = f.w;

        const c = CREDIBILITY_MAP[state.credibility] || CREDIBILITY_MAP.questionable;
        state._credTag = c.tag;
        if (!state.chaosLockedByUser) state.chaos = String(c.chaos);
      }

      function renderControls() {
        controls.innerHTML = "";

        // Creature FIRST (as you requested)
        controls.appendChild(makeSelect({
          id: "classificationSelect",
          label: "CLASSIFICATION",
          options: DATA.classifications,
          placeholder: "Select classification…",
          value: state.classification,
          onChange: (val) => {
            state.classification = val || "";
            clearBelow(["creature", "variant"]);
            renderControls();
            renderPrompt();
          }
        }));

        if (state.classification) {
          controls.appendChild(makeSelect({
            id: "creatureSelect",
            label: "CREATURE",
            options: DATA.creatures[state.classification] || [],
            placeholder: "Select creature…",
            value: state.creature,
            onChange: (val) => {
              state.creature = val || "";
              clearBelow(["variant"]);
              renderControls();
              renderPrompt();
            }
          }));
        }

        const variantOptions = state.creature ? (DATA.variants[state.creature] || []) : [];
        if (state.creature && variantOptions.length) {
          controls.appendChild(makeSelect({
            id: "variantSelect",
            label: "VARIANT",
            options: variantOptions,
            placeholder: "Select variant…",
            value: state.variant,
            onChange: (val) => { state.variant = val || ""; renderPrompt(); }
          }));
        }

        // Visibility (so you can actually see cryptids)
        controls.appendChild(makeSelect({
          id: "visibilitySelect",
          label: "CREATURE VISIBILITY",
          options: DATA.visibility,
          placeholder: "Select visibility…",
          value: state.visibility,
          onChange: (val) => { state.visibility = val || "clear"; renderPrompt(); }
        }));

        // Dials + variability
        controls.appendChild(makeSelect({
          id: "folkloreSelect",
          label: "FOLKLORE INTENSITY",
          options: DATA.folkloreIntensity,
          placeholder: "Select intensity…",
          value: state.folklore,
          onChange: (val) => { state.folklore = val || "1"; renderPrompt(); }
        }));

        controls.appendChild(makeSelect({
          id: "credSelect",
          label: "CREDIBILITY",
          options: DATA.credibility,
          placeholder: "Select credibility…",
          value: state.credibility,
          onChange: (val) => { state.credibility = val || "questionable"; renderPrompt(); }
        }));

        controls.appendChild(makeSelect({
          id: "variationSelect",
          label: "VARIATION",
          options: DATA.variation,
          placeholder: "Select variation…",
          value: state.variation,
          onChange: (val) => { state.variation = val || "med"; renderPrompt(); }
        }));

        // Scene/capture
        controls.appendChild(makeSelect({
          id: "cameraSelect",
          label: "CAPTURE TYPE (OVERRIDES STYLE)",
          options: DATA.cameras,
          placeholder: "Select capture type…",
          value: state.camera,
          onChange: (val) => { state.camera = val || ""; renderPrompt(); }
        }));

        controls.appendChild(makeSelect({
          id: "locationSelect",
          label: "LOCATION",
          options: DATA.locations,
          placeholder: "Select location…",
          value: state.location,
          onChange: (val) => { state.location = val || ""; renderPrompt(); }
        }));

        controls.appendChild(makeSelect({
          id: "atmosphereSelect",
          label: "ATMOSPHERE",
          options: DATA.atmospheres,
          placeholder: "Select atmosphere…",
          value: state.atmosphere,
          onChange: (val) => { state.atmosphere = val || ""; renderPrompt(); }
        }));

        // MJ Params
        controls.appendChild(makeSelect({
          id: "aspectRatioSelect",
          label: "ASPECT RATIO (MJ --ar)",
          options: DATA.aspectRatios,
          placeholder: "Select aspect ratio…",
          value: state.aspectRatio,
          onChange: (val) => { state.aspectRatio = val || "16:9"; renderPrompt(); }
        }));

        controls.appendChild(makeInput({
          id: "chaosInput",
          label: "CHAOS (MJ --chaos 0–100)",
          value: state.chaos,
          placeholder: "0–100",
          min: 0, max: 100, step: 1,
          onInput: (val) => {
            state.chaosLockedByUser = true;
            state.chaos = String(clampInt(val, 0, 100, 10));
            renderPrompt();
          }
        }));

        controls.appendChild(makeSelect({
          id: "qualitySelect",
          label: "QUALITY (MJ --q)",
          options: DATA.quality,
          placeholder: "Select quality…",
          value: state.quality,
          onChange: (val) => { state.quality = val || "1"; renderPrompt(); }
        }));

        controls.appendChild(makeCheckboxRow({
          id: "rawToggle",
          label: "RAW MODE",
          checked: state.raw,
          hint: "--raw",
          onChange: (checked) => { state.raw = checked; renderPrompt(); }
        }));
      }

      function renderPrompt() {
        applyDials();

        // Seeded rng based on current selections + seed, so "Randomize" changes wording
        const key = JSON.stringify({
          seed: state.seed,
          c: state.classification,
          cr: state.creature,
          v: state.variant,
          vis: state.visibility,
          fol: state.folklore,
          cred: state.credibility,
          var: state.variation,
          cam: state.camera,
          loc: state.location,
          atm: state.atmosphere
        });
        const rng = mulberry32(xfnv1a(key));

        const parts = [];

        // --- CREATURE FIRST ---
        let creatureLabel = "";
        if (state.creature && state.classification) {
          const cList = DATA.creatures[state.classification] || [];
          creatureLabel = labelFor(cList, state.creature);
        } else {
          // If you really want cryptids always, you can remove this fallback.
          creatureLabel = "cryptid";
        }

        const visPhrase = pick(rng, VISIBILITY_TAGS[state.visibility] || VISIBILITY_TAGS.clear);

        parts.push(`${creatureLabel}`);
        if (state.variant && state.creature) {
          const vLabel = labelFor(DATA.variants[state.creature], state.variant);
          parts.push(vLabel);
        }
        parts.push(visPhrase);

        // --- STYLE / WORDING VARIATION ---
        const variationLevel = state.variation;
        const opener = pick(rng, OPENERS);
        const comp = pick(rng, COMPOSITION);
        const tone = pick(rng, TONE);

        parts.push(opener);
        parts.push(comp);

        // Camera profile overrides (adds camera-specific text)
        if (state.camera && CAMERA_PROFILES[state.camera]) {
          const camBits = CAMERA_PROFILES[state.camera];
          // low/med/high control how many camera bits we include
          const camCount = (variationLevel === "low") ? 2 : (variationLevel === "med") ? 3 : 3;
          sampleN(rng, camBits, camCount).forEach(s => parts.push(s));
        }

        // Credibility tag
        if (state._credTag) parts.push(state._credTag);

        // Location/atmosphere next
        if (state.location) parts.push(`location: ${labelFor(DATA.locations, state.location)}`);
        if (state.atmosphere) parts.push(`atmosphere: ${labelFor(DATA.atmospheres, state.atmosphere)}`);

        // Artifacts: choose more when variation higher
        const artCount = (variationLevel === "low") ? 2 : (variationLevel === "med") ? 3 : 4;
        sampleN(rng, ARTIFACTS, artCount).forEach(s => parts.push(s));

        // Micro details: only on med/high to avoid always repeating
        if (variationLevel !== "low") {
          const microCount = (variationLevel === "med") ? 1 : 2;
          sampleN(rng, MICRO_DETAILS, microCount).forEach(s => parts.push(s));
        }

        parts.push(tone);

        const descriptive = parts.filter(Boolean).join(", ");

        // MJ params
        const params = [];
        params.push(`--ar ${state.aspectRatio || "16:9"}`);

        const chaos = clampInt(state.chaos, 0, 100, 10);
        params.push(`--chaos ${chaos}`);

        if (state.raw) params.push(`--raw`);

        // dials always included (your “instrument”)
        params.push(`--s ${state._stylize}`);
        params.push(`--w ${state._weird}`);

        const q = (state.quality === "2" || state.quality === "4") ? state.quality : "1";
        if (q !== "1") params.push(`--q ${q}`);

        finalPrompt.value = descriptive + " " + params.join(" ");
        statusPill.textContent = "MJ Params: " + params.join(" ");
      }

      async function copyPrompt() {
        copyHint.textContent = "";
        const text = finalPrompt.value;
        try {
          await navigator.clipboard.writeText(text);
          copyHint.textContent = "Copied to clipboard.";
        } catch (e) {
          finalPrompt.focus();
          finalPrompt.select();
          document.execCommand("copy");
          copyHint.textContent = "Copied (fallback).";
        }
        setTimeout(() => (copyHint.textContent = ""), 1400);
      }

      function resetAll() {
        state.classification = "cryptid";
        state.creature = "";
        state.variant = "";
        state.visibility = "clear";

        state.folklore = "1";
        state.credibility = "questionable";
        state.variation = "med";

        state.camera = "35mm";
        state.location = "";
        state.atmosphere = "";

        state.aspectRatio = "16:9";
        state.chaos = "10";
        state.raw = false;
        state.quality = "1";

        state.chaosLockedByUser = false;
        state.seed = 1;

        copyHint.textContent = "";
        renderControls();
        renderPrompt();
      }

      function bumpSeed() {
        // changes wording without changing selections
        state.seed = (state.seed + 1) % 1000000;
        renderPrompt();
      }

      copyBtn.addEventListener("click", copyPrompt);
      resetBtn.addEventListener("click", resetAll);
      randomBtn.addEventListener("click", bumpSeed);

      renderControls();
      renderPrompt();
    })();
  </script>
</body>
</html>
