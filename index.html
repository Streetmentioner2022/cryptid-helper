<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>NAFO • Style Prompt Generator</title>

  <style>
    :root{
      --bg: #07090d;
      --panel: rgba(255,255,255,.04);
      --border: rgba(255,255,255,.12);
      --border2: rgba(255,255,255,.18);
      --text: rgba(255,255,255,.92);
      --muted: rgba(255,255,255,.72);
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
      --sans: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      --radius: 16px;
    }

    *{ box-sizing: border-box; }
    html, body { height: 100%; }
    body{
      margin: 0;
      font-family: var(--sans);
      background: radial-gradient(1200px 600px at 20% -10%, rgba(255,255,255,.06), transparent 55%),
                  radial-gradient(900px 500px at 90% 10%, rgba(255,255,255,.05), transparent 60%),
                  var(--bg);
      color: var(--text);
      overflow-x: hidden;
    }

    /* Subtle CRT scanlines + noise */
    .scanlines::before{
      content:"";
      position: fixed;
      inset: 0;
      pointer-events: none;
      background:
        repeating-linear-gradient(
          to bottom,
          rgba(255,255,255,.03) 0px,
          rgba(255,255,255,.03) 1px,
          rgba(0,0,0,0) 2px,
          rgba(0,0,0,0) 4px
        );
      mix-blend-mode: overlay;
      opacity: .35;
      z-index: 40;
    }
    .scanlines::after{
      content:"";
      position: fixed;
      inset: 0;
      pointer-events: none;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='180' height='180'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='.9' numOctaves='2' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='180' height='180' filter='url(%23n)' opacity='.22'/%3E%3C/svg%3E");
      opacity: .06;
      z-index: 41;
    }

    .wrap{
      max-width: 1100px;
      margin: 0 auto;
      padding: 18px 16px 40px;
    }

    /* Top "CLASSIFIED" bar */
    .classbar{
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      border: 1px solid var(--border);
      background: rgba(0,0,0,.28);
      border-radius: var(--radius);
      padding: 10px 12px;
      margin-bottom: 14px;
      backdrop-filter: blur(6px);
    }
    .classbar span{
      letter-spacing: .14em;
      font-size: 12px;
      text-transform: uppercase;
      color: var(--muted);
    }
    .mono{ font-family: var(--mono); }

    /* Title block */
    .titleblock{
      border: 1px solid var(--border);
      background: rgba(0,0,0,.22);
      border-radius: var(--radius);
      padding: 14px 14px;
      margin-bottom: 14px;
      backdrop-filter: blur(6px);
    }
    .titleblock h1{
      margin: 0 0 6px;
      font-size: 18px;
      letter-spacing: .06em;
      text-transform: uppercase;
    }
    .titleblock p{
      margin: 0;
      color: var(--muted);
      line-height: 1.45;
    }

    /* Panel + generator layout */
    .panel{
      border: 1px solid var(--border);
      background: var(--panel);
      border-radius: var(--radius);
      padding: 16px;
      backdrop-filter: blur(6px);
    }
    .panel-title{
      margin: 0 0 6px;
      font-size: 16px;
      letter-spacing: .06em;
      text-transform: uppercase;
    }
    .panel-subtitle{
      margin: 0 0 14px;
      color: var(--muted);
      line-height: 1.45;
    }

    .grid{
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 14px;
    }
    @media (max-width: 900px){
      .grid{ grid-template-columns: 1fr; }
    }

    .controls{ display: grid; gap: 12px; }

    .field{ display: grid; gap: 6px; }
    .label{
      font-size: 12px;
      letter-spacing: .14em;
      opacity: .9;
      text-transform: uppercase;
    }

    .select, .textarea, .input{
      width: 100%;
      border-radius: 12px;
      border: 1px solid var(--border);
      padding: 10px 12px;
      background: rgba(0,0,0,.35);
      color: var(--text);
      outline: none;
    }
    .select:focus, .textarea:focus, .input:focus{
      border-color: rgba(255,255,255,.22);
      box-shadow: 0 0 0 3px rgba(255,255,255,.05);
    }

    .row{ display: flex; gap: 10px; margin-top: 10px; flex-wrap: wrap; }
    .btn{
      border-radius: 12px;
      border: 1px solid var(--border2);
      background: rgba(255,255,255,.06);
      padding: 10px 12px;
      cursor: pointer;
      color: var(--text);
      letter-spacing: .08em;
      text-transform: uppercase;
      font-size: 12px;
    }
    .btn:hover{ background: rgba(255,255,255,.10); }
    .btn.ghost{ background: transparent; opacity: .9; }

    .hint{ margin: 10px 0 0; color: var(--muted); min-height: 18px; }
    .divider{
      height: 1px;
      background: rgba(255,255,255,.08);
      margin: 14px 0;
    }
    .footer{
      margin-top: 14px;
      color: var(--muted);
      font-size: 12px;
      letter-spacing: .08em;
      text-transform: uppercase;
    }

    /* checkbox row */
    .checkrow{
      display: flex;
      align-items: center;
      gap: 10px;
      border: 1px solid var(--border);
      background: rgba(0,0,0,.25);
      padding: 10px 12px;
      border-radius: 12px;
    }
    .checkrow input{ transform: scale(1.15); }
    .checkrow .labeltext{
      letter-spacing: .14em;
      text-transform: uppercase;
      font-size: 12px;
      opacity: .9;
    }
    .checkrow .sub{
      margin-left: auto;
      font-size: 12px;
      opacity: .7;
    }
  </style>
</head>

<body class="scanlines">
  <div class="wrap">
    <div class="classbar">
      <span>CLASSIFIED • FIELD REPORT</span>
      <span class="mono">ARCHIVE NODE 32</span>
    </div>

    <div class="titleblock">
      <h1 class="mono">National Anomaly Field Office</h1>
      <p class="mono">Style Prompt Generator • officially denied</p>
    </div>

    <section class="panel" id="prompt-generator">
      <h2 class="panel-title mono">Prompt Composer</h2>
      <p class="panel-subtitle mono">Classification → Creature → (Variant) → Location → Atmosphere → Capture Type → MJ Params</p>

      <div class="grid">
        <div class="controls" id="controls"></div>

        <div class="output">
          <label class="label mono" for="finalPrompt">FINAL PROMPT</label>
          <textarea id="finalPrompt" class="textarea mono" rows="12" readonly></textarea>

          <div class="row">
            <button class="btn mono" id="copyBtn" type="button">Copy</button>
            <button class="btn ghost mono" id="resetBtn" type="button">Reset</button>
          </div>

          <p class="hint mono" id="copyHint" aria-live="polite"></p>

          <div class="divider"></div>
          <div class="footer mono">NAFO // INTERNAL TOOLING // DO NOT DISTRIBUTE</div>
        </div>
      </div>
    </section>
  </div>

  <script>
    (() => {
      const DATA = {
        classifications: [
          { value: "cryptid", label: "Cryptid" },
          { value: "fae", label: "Fae" },
          { value: "apparition", label: "Apparition" },
          { value: "aberration", label: "Aberration" },
          { value: "entity", label: "Unknown Entity" },
          { value: "artifact", label: "Anomalous Artifact" }
        ],

        creatures: {
          cryptid: [
            { value: "mothman", label: "Mothman" },
            { value: "jersey_devil", label: "Jersey Devil" },
            { value: "bigfoot", label: "Bigfoot / Sasquatch" },
            { value: "chupacabra", label: "Chupacabra" },
            { value: "dover_demon", label: "Dover Demon" },
            { value: "flatwoods", label: "Flatwoods Monster" }
          ],
          fae: [
            { value: "wild_hunt", label: "The Wild Hunt" },
            { value: "leprechaun", label: "Leprechaun" },
            { value: "selkie", label: "Selkie" },
            { value: "redcap", label: "Redcap" },
            { value: "brownie", label: "Brownie" },
            { value: "banshee", label: "Banshee" }
          ],
          apparition: [
            { value: "woman_in_white", label: "Woman in White" },
            { value: "black_dog", label: "Black Dog" },
            { value: "headless_rider", label: "Headless Rider" },
            { value: "poltergeist", label: "Poltergeist" },
            { value: "shadow_person", label: "Shadow Person" }
          ],
          aberration: [
            { value: "fleshgait", label: "Fleshgait" },
            { value: "mimic", label: "Mimic" },
            { value: "crawler", label: "Pale Crawler" },
            { value: "things_that_knock", label: "Things That Knock" }
          ],
          entity: [
            { value: "unknown_biologic", label: "Unknown Biologic" },
            { value: "unknown_humanoid", label: "Unknown Humanoid" },
            { value: "unknown_aerial", label: "Unknown Aerial" },
            { value: "unknown_aquatic", label: "Unknown Aquatic" }
          ],
          artifact: [
            { value: "cursed_relic", label: "Cursed Relic" },
            { value: "impossible_device", label: "Impossible Device" },
            { value: "forbidden_text", label: "Forbidden Text" },
            { value: "anomalous_signal", label: "Anomalous Signal Source" }
          ]
        },

        variants: {
          mothman: [
            { value: "red_eyes", label: "Red-Eyed Silhouette" },
            { value: "ash_wings", label: "Ash-Dusted Wings" },
            { value: "bridge_omen", label: "Bridge Omen" }
          ],
          jersey_devil: [
            { value: "pine_barrens", label: "Pine Barrens Stalker" },
            { value: "hoofprints", label: "Hoofprint Trail" }
          ],
          wild_hunt: [
            { value: "horned_riders", label: "Horned Riders" },
            { value: "hounds", label: "Black Hounds" },
            { value: "winter_procession", label: "Winter Procession" }
          ]
        },

        locations: [
          { value: "pine_forest", label: "Pine forest" },
          { value: "abandoned_mill", label: "Abandoned mill" },
          { value: "rural_road", label: "Rural road" },
          { value: "swamp", label: "Swamp" },
          { value: "coastal_cliffs", label: "Coastal cliffs" },
          { value: "suburban_woods", label: "Suburban treeline" },
          { value: "derelict_town", label: "Derelict town" }
        ],

        atmospheres: [
          { value: "fog", label: "Fog" },
          { value: "thunderstorm", label: "Thunderstorm" },
          { value: "heavy_rain", label: "Heavy rain" },
          { value: "snow", label: "Snow" },
          { value: "low_mist", label: "Low ground mist" },
          { value: "moonless_night", label: "Moonless night" },
          { value: "sodium_vapor", label: "Sodium-vapor streetlight haze" }
        ],

        cameras: [
          { value: "35mm", label: "35mm film photo" },
          { value: "polaroid", label: "Polaroid" },
          { value: "cctv", label: "CCTV still" },
          { value: "handheld_video", label: "Handheld camcorder frame" },
          { value: "thermal", label: "Thermal imaging" },
          { value: "night_vision", label: "Night vision" }
        ],

        aspectRatios: [
          { value: "1:1", label: "1:1 (Square)" },
          { value: "3:2", label: "3:2 (35mm photo)" },
          { value: "2:3", label: "2:3 (Portrait photo)" },
          { value: "4:3", label: "4:3 (Old video)" },
          { value: "16:9", label: "16:9 (Widescreen)" },
          { value: "9:16", label: "9:16 (Vertical)" },
          { value: "21:9", label: "21:9 (Ultra-wide)" }
        ],

        quality: [
          { value: "1", label: "1 (Default)" },
          { value: "2", label: "2 (More detail / more GPU)" },
          { value: "4", label: "4 (Max detail / more GPU)" }
        ]
      };

      // Found footage + analog folklore base (MJ-useful language)
      const DEFAULT_STYLE_BASE = [
        "found footage documentary photograph",
        "accidental folklore documentation",
        "imperfect framing, unsteady composition",
        "natural low light exposure",
        "no cinematic polish"
      ];

      // Camera overrides (option 1)
      const CAMERA_PROFILES = {
        "35mm": [
          "found footage documentary photograph",
          "accidental folklore documentation",
          "authentic 35mm film photograph",
          "visible analog film grain",
          "slight underexposure, imperfect focus",
          "imperfect framing, candid moment",
          "no cinematic polish"
        ],
        "polaroid": [
          "found footage documentary photograph",
          "accidental folklore documentation",
          "polaroid instant photo",
          "soft focus, uneven exposure",
          "chemical artifacts, faded color cast",
          "handheld snapshot composition",
          "no cinematic polish"
        ],
        "cctv": [
          "surveillance camera still",
          "paranormal incident documentation",
          "fixed wide angle, unflattering perspective",
          "low resolution, compression artifacts",
          "timestamped security footage aesthetic",
          "harsh overhead lighting or dim ambient light"
        ],
        "handheld_video": [
          "found footage camcorder frame",
          "accidental folklore documentation",
          "handheld documentary video still",
          "motion blur, rolling shutter artifacts",
          "imperfect focus, low light noise",
          "no cinematic polish"
        ],
        "thermal": [
          "thermal imaging still",
          "incident documentation",
          "heat signature contrast, sensor noise",
          "low detail edges, utilitarian capture",
          "unsettling ambiguity, non-cinematic"
        ],
        "night_vision": [
          "night vision footage still",
          "incident documentation",
          "infrared glow, high noise",
          "crushed blacks, blown highlights",
          "unsteady handheld framing",
          "non-cinematic, purely observational"
        ]
      };

      // State (defaults chosen to keep output clean)
      const state = {
        classification: "",
        creature: "",
        variant: "",
        location: "",
        atmosphere: "",
        camera: "",
        aspectRatio: "16:9",
        chaos: "10",
        raw: false,
        stylize: "100",   // default 100; omitted unless changed
        weird: "0",       // default 0; omitted unless changed
        quality: "1"      // default 1; omitted unless changed
      };

      const controls = document.getElementById("controls");
      const finalPrompt = document.getElementById("finalPrompt");
      const copyBtn = document.getElementById("copyBtn");
      const resetBtn = document.getElementById("resetBtn");
      const copyHint = document.getElementById("copyHint");

      function el(tag, attrs = {}, children = []) {
        const node = document.createElement(tag);
        Object.entries(attrs).forEach(([k, v]) => {
          if (k === "class") node.className = v;
          else if (k === "for") node.htmlFor = v;
          else if (k === "checked") node.checked = !!v;
          else node.setAttribute(k, v);
        });
        children.forEach(c => node.appendChild(typeof c === "string" ? document.createTextNode(c) : c));
        return node;
      }

      function makeSelect({ id, label, options, placeholder = "Select…", value, onChange }) {
        const select = el("select", { id, class: "select mono" });
        select.appendChild(el("option", { value: "" }, [placeholder]));
        options.forEach(opt => select.appendChild(el("option", { value: opt.value }, [opt.label])));
        select.value = value || "";
        select.addEventListener("change", (e) => onChange(e.target.value));

        return el("div", { class: "field" }, [
          el("label", { class: "label mono", for: id }, [label]),
          select
        ]);
      }

      function makeInput({ id, label, value, placeholder = "", onInput, type = "number", min, max, step }) {
        const attrs = { id, class: "input mono", value: value ?? "", placeholder, type };
        if (min !== undefined) attrs.min = String(min);
        if (max !== undefined) attrs.max = String(max);
        if (step !== undefined) attrs.step = String(step);

        const input = el("input", attrs);
        input.addEventListener("input", (e) => onInput(e.target.value));

        return el("div", { class: "field" }, [
          el("label", { class: "label mono", for: id }, [label]),
          input
        ]);
      }

      function makeCheckbox({ id, label, checked, hint, onChange }) {
        const box = el("input", { id, type: "checkbox", checked });
        box.addEventListener("change", (e) => onChange(e.target.checked));

        return el("div", { class: "checkrow" }, [
          box,
          el("div", { class: "labeltext mono" }, [label]),
          el("div", { class: "sub mono" }, [hint || ""])
        ]);
      }

      function clampInt(v, min, max, fallback) {
        const n = parseInt(v, 10);
        if (Number.isNaN(n)) return fallback;
        return Math.min(max, Math.max(min, n));
      }

      function clearBelow(keys) { keys.forEach(k => state[k] = ""); }

      function labelFor(list, value) {
        const item = (list || []).find(x => x.value === value);
        return item ? item.label : "";
      }

      function renderControls() {
        controls.innerHTML = "";

        // 1) Classification
        controls.appendChild(makeSelect({
          id: "classificationSelect",
          label: "CLASSIFICATION",
          options: DATA.classifications,
          placeholder: "Select classification…",
          value: state.classification,
          onChange: (val) => {
            state.classification = val;
            clearBelow(["creature", "variant", "location", "atmosphere", "camera"]);
            renderControls();
            renderPrompt();
          }
        }));

        // 2) Creature
        if (state.classification) {
          controls.appendChild(makeSelect({
            id: "creatureSelect",
            label: "CREATURE",
            options: DATA.creatures[state.classification] || [],
            placeholder: "Select creature…",
            value: state.creature,
            onChange: (val) => {
              state.creature = val;
              clearBelow(["variant", "location", "atmosphere", "camera"]);
              renderControls();
              renderPrompt();
            }
          }));
        }

        // 3) Variant
        const variantOptions = state.creature ? (DATA.variants[state.creature] || []) : [];
        if (state.creature && variantOptions.length) {
          controls.appendChild(makeSelect({
            id: "variantSelect",
            label: "VARIANT",
            options: variantOptions,
            placeholder: "Select variant…",
            value: state.variant,
            onChange: (val) => {
              state.variant = val;
              renderPrompt();
            }
          }));
        }

        if (state.creature) {
          // 4) Location
          controls.appendChild(makeSelect({
            id: "locationSelect",
            label: "LOCATION",
            options: DATA.locations,
            placeholder: "Select location…",
            value: state.location,
            onChange: (val) => { state.location = val; renderPrompt(); }
          }));

          // 5) Atmosphere
          controls.appendChild(makeSelect({
            id: "atmosphereSelect",
            label: "ATMOSPHERE",
            options: DATA.atmospheres,
            placeholder: "Select atmosphere…",
            value: state.atmosphere,
            onChange: (val) => { state.atmosphere = val; renderPrompt(); }
          }));

          // 6) Camera (overrides style)
          controls.appendChild(makeSelect({
            id: "cameraSelect",
            label: "CAPTURE TYPE (OVERRIDES STYLE)",
            options: DATA.cameras,
            placeholder: "Select capture type…",
            value: state.camera,
            onChange: (val) => { state.camera = val; renderPrompt(); }
          }));

          // MJ PARAMS
          controls.appendChild(makeSelect({
            id: "aspectRatioSelect",
            label: "ASPECT RATIO (MJ --ar)",
            options: DATA.aspectRatios,
            placeholder: "Select aspect ratio…",
            value: state.aspectRatio,
            onChange: (val) => { state.aspectRatio = val || "16:9"; renderPrompt(); }
          }));

          controls.appendChild(makeInput({
            id: "chaosInput",
            label: "CHAOS (MJ --chaos 0–100)",
            value: state.chaos,
            placeholder: "0–100 (e.g. 10)",
            min: 0, max: 100, step: 1,
            onInput: (val) => { state.chaos = String(clampInt(val, 0, 100, 10)); renderPrompt(); }
          }));

          controls.appendChild(makeCheckbox({
            id: "rawToggle",
            label: "RAW MODE",
            checked: state.raw,
            hint: "--raw",
            onChange: (checked) => { state.raw = checked; renderPrompt(); }
          }));

          controls.appendChild(makeInput({
            id: "stylizeInput",
            label: "STYLIZE (MJ --s 0–1000)",
            value: state.stylize,
            placeholder: "0–1000 (default 100)",
            min: 0, max: 1000, step: 1,
            onInput: (val) => { state.stylize = String(clampInt(val, 0, 1000, 100)); renderPrompt(); }
          }));

          controls.appendChild(makeInput({
            id: "weirdInput",
            label: "WEIRD (MJ --w 0–3000)",
            value: state.weird,
            placeholder: "0–3000 (default 0)",
            min: 0, max: 3000, step: 1,
            onInput: (val) => { state.weird = String(clampInt(val, 0, 3000, 0)); renderPrompt(); }
          }));

          controls.appendChild(makeSelect({
            id: "qualitySelect",
            label: "QUALITY (MJ --q)",
            options: DATA.quality,
            placeholder: "Select quality…",
            value: state.quality,
            onChange: (val) => { state.quality = val || "1"; renderPrompt(); }
          }));
        }
      }

      function renderPrompt() {
        const parts = [];

        // camera overrides base
        const base = (state.camera && CAMERA_PROFILES[state.camera])
          ? CAMERA_PROFILES[state.camera]
          : DEFAULT_STYLE_BASE;

        base.forEach(s => parts.push(s));

        if (state.classification) parts.push(`classification: ${labelFor(DATA.classifications, state.classification)}`);

        if (state.creature) {
          const cList = DATA.creatures[state.classification] || [];
          parts.push(`subject: ${labelFor(cList, state.creature)}`);
        }

        if (state.variant) parts.push(`variant: ${labelFor(DATA.variants[state.creature], state.variant)}`);
        if (state.location) parts.push(`location: ${labelFor(DATA.locations, state.location)}`);
        if (state.atmosphere) parts.push(`atmosphere: ${labelFor(DATA.atmospheres, state.atmosphere)}`);

        // keep this minimal and MJ-useful
        parts.push("subtle scanlines, archival wear, restrained horror");

        const descriptive = parts.join(", ");

        // params at end (space-separated)
        const params = [];

        // Always include ar/chaos (you can change to "only if not default" if you want)
        const ar = state.aspectRatio || "16:9";
        params.push(`--ar ${ar}`);

        const chaos = clampInt(state.chaos, 0, 100, 10);
        params.push(`--chaos ${chaos}`);

        if (state.raw) params.push(`--raw`);

        const s = clampInt(state.stylize, 0, 1000, 100);
        if (s !== 100) params.push(`--s ${s}`);

        const w = clampInt(state.weird, 0, 3000, 0);
        if (w !== 0) params.push(`--w ${w}`);

        const q = String(clampInt(state.quality, 1, 4, 1));
        // only allow 1/2/4; if someone types 3 it clamps to 3, so normalize:
        const qNorm = (q === "2" || q === "4") ? q : "1";
        if (qNorm !== "1") params.push(`--q ${qNorm}`);

        finalPrompt.value = descriptive + " " + params.join(" ");
      }

      async function copyPrompt() {
        copyHint.textContent = "";
        const text = finalPrompt.value;

        try {
          await navigator.clipboard.writeText(text);
          copyHint.textContent = "Copied to clipboard.";
        } catch (e) {
          finalPrompt.focus();
          finalPrompt.select();
          document.execCommand("copy");
          copyHint.textContent = "Copied (fallback).";
        }

        setTimeout(() => (copyHint.textContent = ""), 1400);
      }

      function resetAll() {
        state.classification = "";
        state.creature = "";
        state.variant = "";
        state.location = "";
        state.atmosphere = "";
        state.camera = "";
        state.aspectRatio = "16:9";
        state.chaos = "10";
        state.raw = false;
        state.stylize = "100";
        state.weird = "0";
        state.quality = "1";
        copyHint.textContent = "";
        renderControls();
        renderPrompt();
      }

      copyBtn.addEventListener("click", copyPrompt);
      resetBtn.addEventListener("click", resetAll);

      renderControls();
      renderPrompt();
    })();
  </script>
</body>
</html>
