<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>NAFO • Style Prompt Generator</title>

  <style>
    :root{
      --bg: #07090d;
      --panel: rgba(255,255,255,.04);
      --border: rgba(255,255,255,.12);
      --border2: rgba(255,255,255,.18);
      --text: rgba(255,255,255,.92);
      --muted: rgba(255,255,255,.72);
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
      --sans: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      --radius: 16px;
    }

    *{ box-sizing: border-box; }
    html, body { height: 100%; }
    body{
      margin: 0;
      font-family: var(--sans);
      background: radial-gradient(1200px 600px at 20% -10%, rgba(255,255,255,.06), transparent 55%),
                  radial-gradient(900px 500px at 90% 10%, rgba(255,255,255,.05), transparent 60%),
                  var(--bg);
      color: var(--text);
      overflow-x: hidden;
    }

    /* Subtle CRT scanlines + noise */
    .scanlines::before{
      content:"";
      position: fixed;
      inset: 0;
      pointer-events: none;
      background:
        repeating-linear-gradient(
          to bottom,
          rgba(255,255,255,.03) 0px,
          rgba(255,255,255,.03) 1px,
          rgba(0,0,0,0) 2px,
          rgba(0,0,0,0) 4px
        );
      mix-blend-mode: overlay;
      opacity: .35;
      z-index: 40;
    }
    .scanlines::after{
      content:"";
      position: fixed;
      inset: 0;
      pointer-events: none;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='180' height='180'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='.9' numOctaves='2' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='180' height='180' filter='url(%23n)' opacity='.22'/%3E%3C/svg%3E");
      opacity: .06;
      z-index: 41;
    }

    .wrap{
      max-width: 1100px;
      margin: 0 auto;
      padding: 18px 16px 40px;
    }

    /* Top "CLASSIFIED" bar */
    .classbar{
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      border: 1px solid var(--border);
      background: rgba(0,0,0,.28);
      border-radius: var(--radius);
      padding: 10px 12px;
      margin-bottom: 14px;
      backdrop-filter: blur(6px);
    }
    .classbar span{
      letter-spacing: .14em;
      font-size: 12px;
      text-transform: uppercase;
      color: var(--muted);
    }
    .mono{ font-family: var(--mono); }

    /* Title block */
    .titleblock{
      border: 1px solid var(--border);
      background: rgba(0,0,0,.22);
      border-radius: var(--radius);
      padding: 14px 14px;
      margin-bottom: 14px;
      backdrop-filter: blur(6px);
    }
    .titleblock h1{
      margin: 0 0 6px;
      font-size: 18px;
      letter-spacing: .06em;
      text-transform: uppercase;
    }
    .titleblock p{
      margin: 0;
      color: var(--muted);
      line-height: 1.45;
    }

    /* Panel + generator layout */
    .panel{
      border: 1px solid var(--border);
      background: var(--panel);
      border-radius: var(--radius);
      padding: 16px;
      backdrop-filter: blur(6px);
    }
    .panel-title{
      margin: 0 0 6px;
      font-size: 16px;
      letter-spacing: .06em;
      text-transform: uppercase;
    }
    .panel-subtitle{
      margin: 0 0 14px;
      color: var(--muted);
      line-height: 1.45;
    }

    .grid{
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 14px;
    }
    @media (max-width: 900px){
      .grid{ grid-template-columns: 1fr; }
    }

    .controls{ display: grid; gap: 12px; }

    .field{ display: grid; gap: 6px; }
    .label{
      font-size: 12px;
      letter-spacing: .14em;
      opacity: .9;
      text-transform: uppercase;
    }

    .select, .textarea{
      width: 100%;
      border-radius: 12px;
      border: 1px solid var(--border);
      padding: 10px 12px;
      background: rgba(0,0,0,.35);
      color: var(--text);
      outline: none;
    }
    .select:focus, .textarea:focus{
      border-color: rgba(255,255,255,.22);
      box-shadow: 0 0 0 3px rgba(255,255,255,.05);
    }

    .row{ display: flex; gap: 10px; margin-top: 10px; flex-wrap: wrap; }
    .btn{
      border-radius: 12px;
      border: 1px solid var(--border2);
      background: rgba(255,255,255,.06);
      padding: 10px 12px;
      cursor: pointer;
      color: var(--text);
      letter-spacing: .08em;
      text-transform: uppercase;
      font-size: 12px;
    }
    .btn:hover{ background: rgba(255,255,255,.10); }
    .btn.ghost{ background: transparent; opacity: .9; }

    .hint{ margin: 10px 0 0; color: var(--muted); min-height: 18px; }
    .divider{
      height: 1px;
      background: rgba(255,255,255,.08);
      margin: 14px 0;
    }
    .footer{
      margin-top: 14px;
      color: var(--muted);
      font-size: 12px;
      letter-spacing: .08em;
      text-transform: uppercase;
    }
  </style>
</head>

<body class="scanlines">
  <div class="wrap">
    <div class="classbar">
      <span>CLASSIFIED • FIELD REPORT</span>
      <span class="mono">ARCHIVE NODE 32</span>
    </div>

    <div class="titleblock">
      <h1 class="mono">National Anomaly Field Office</h1>
      <p class="mono">NAFO Style Prompt Generator • officially denied</p>
    </div>

    <section class="panel" id="prompt-generator">
      <h2 class="panel-title mono">Prompt Composer</h2>
      <p class="panel-subtitle mono">Classification → Creature → (Variant) → Location → Atmosphere → Capture Type</p>

      <div class="grid">
        <!-- Left: Controls -->
        <div class="controls" id="controls"></div>

        <!-- Right: Output -->
        <div class="output">
          <label class="label mono" for="finalPrompt">FINAL PROMPT</label>
          <textarea id="finalPrompt" class="textarea mono" rows="12" readonly></textarea>

          <div class="row">
            <button class="btn mono" id="copyBtn" type="button">Copy</button>
            <button class="btn ghost mono" id="resetBtn" type="button">Reset</button>
          </div>

          <p class="hint mono" id="copyHint" aria-live="polite"></p>

          <div class="divider"></div>
          <div class="footer mono">NAFO // INTERNAL TOOLING // DO NOT DISTRIBUTE</div>
        </div>
      </div>
    </section>
  </div>

  <script>
    (() => {
      // ===== Data model =====
      const DATA = {
        classifications: [
          { value: "cryptid", label: "Cryptid" },
          { value: "fae", label: "Fae" },
          { value: "apparition", label: "Apparition" },
          { value: "aberration", label: "Aberration" },
          { value: "entity", label: "Unknown Entity" },
          { value: "artifact", label: "Anomalous Artifact" }
        ],

        // Creature lists by classification
        creatures: {
          cryptid: [
            { value: "mothman", label: "Mothman" },
            { value: "jersey_devil", label: "Jersey Devil" },
            { value: "bigfoot", label: "Bigfoot / Sasquatch" },
            { value: "chupacabra", label: "Chupacabra" },
            { value: "dover_demon", label: "Dover Demon" },
            { value: "flatwoods", label: "Flatwoods Monster" }
          ],
          fae: [
            { value: "wild_hunt", label: "The Wild Hunt" },
            { value: "leprechaun", label: "Leprechaun" },
            { value: "selkie", label: "Selkie" },
            { value: "redcap", label: "Redcap" },
            { value: "brownie", label: "Brownie" },
            { value: "banshee", label: "Banshee" }
          ],
          apparition: [
            { value: "woman_in_white", label: "Woman in White" },
            { value: "black_dog", label: "Black Dog" },
            { value: "headless_rider", label: "Headless Rider" },
            { value: "poltergeist", label: "Poltergeist" },
            { value: "shadow_person", label: "Shadow Person" }
          ],
          aberration: [
            { value: "fleshgait", label: "Fleshgait" },
            { value: "mimic", label: "Mimic" },
            { value: "crawler", label: "Pale Crawler" },
            { value: "things_that_knock", label: "Things That Knock" }
          ],
          entity: [
            { value: "unknown_biologic", label: "Unknown Biologic" },
            { value: "unknown_humanoid", label: "Unknown Humanoid" },
            { value: "unknown_aerial", label: "Unknown Aerial" },
            { value: "unknown_aquatic", label: "Unknown Aquatic" }
          ],
          artifact: [
            { value: "cursed_relic", label: "Cursed Relic" },
            { value: "impossible_device", label: "Impossible Device" },
            { value: "forbidden_text", label: "Forbidden Text" },
            { value: "anomalous_signal", label: "Anomalous Signal Source" }
          ]
        },

        // Optional variants only for SOME creatures
        variants: {
          mothman: [
            { value: "red_eyes", label: "Red-Eyed Silhouette" },
            { value: "ash_wings", label: "Ash-Dusted Wings" },
            { value: "bridge_omen", label: "Bridge Omen" }
          ],
          jersey_devil: [
            { value: "pine_barrens", label: "Pine Barrens Stalker" },
            { value: "hoofprints", label: "Hoofprint Trail" }
          ],
          wild_hunt: [
            { value: "horned_riders", label: "Horned Riders" },
            { value: "hounds", label: "Black Hounds" },
            { value: "winter_procession", label: "Winter Procession" }
          ]
        },

        locations: [
          { value: "pine_forest", label: "Pine forest" },
          { value: "abandoned_mill", label: "Abandoned mill" },
          { value: "rural_road", label: "Rural road" },
          { value: "swamp", label: "Swamp" },
          { value: "coastal_cliffs", label: "Coastal cliffs" },
          { value: "suburban_woods", label: "Suburban treeline" },
          { value: "derelict_town", label: "Derelict town" }
        ],

        atmospheres: [
          { value: "fog", label: "Fog" },
          { value: "thunderstorm", label: "Thunderstorm" },
          { value: "heavy_rain", label: "Heavy rain" },
          { value: "snow", label: "Snow" },
          { value: "low_mist", label: "Low ground mist" },
          { value: "moonless_night", label: "Moonless night" },
          { value: "sodium_vapor", label: "Sodium-vapor streetlight haze" }
        ],

        cameras: [
          { value: "35mm", label: "35mm film photo" },
          { value: "polaroid", label: "Polaroid" },
          { value: "cctv", label: "CCTV still" },
          { value: "handheld_video", label: "Handheld camcorder frame" },
          { value: "thermal", label: "Thermal imaging" },
          { value: "night_vision", label: "Night vision" }
        ]
      };

      // ===== State =====
      const state = {
        classification: "",
        creature: "",
        variant: "",
        location: "",
        atmosphere: "",
        camera: ""
      };

      // ===== DOM =====
      const controls = document.getElementById("controls");
      const finalPrompt = document.getElementById("finalPrompt");
      const copyBtn = document.getElementById("copyBtn");
      const resetBtn = document.getElementById("resetBtn");
      const copyHint = document.getElementById("copyHint");

      // ===== helpers =====
      function el(tag, attrs = {}, children = []) {
        const node = document.createElement(tag);
        Object.entries(attrs).forEach(([k, v]) => {
          if (k === "class") node.className = v;
          else if (k === "for") node.htmlFor = v;
          else node.setAttribute(k, v);
        });
        children.forEach(c => node.appendChild(typeof c === "string" ? document.createTextNode(c) : c));
        return node;
      }

      function makeSelect({ id, label, options, placeholder = "Select…", value, onChange }) {
        const select = el("select", { id, class: "select mono" });
        select.appendChild(el("option", { value: "" }, [placeholder]));
        options.forEach(opt => {
          select.appendChild(el("option", { value: opt.value }, [opt.label]));
        });
        select.value = value || "";
        select.addEventListener("change", (e) => onChange(e.target.value));

        return el("div", { class: "field" }, [
          el("label", { class: "label mono", for: id }, [label]),
          select
        ]);
      }

      function clearBelow(keys) {
        keys.forEach(k => state[k] = "");
      }

      function labelFor(list, value) {
        const item = (list || []).find(x => x.value === value);
        return item ? item.label : "";
      }

      // ===== Render =====
      function renderControls() {
        controls.innerHTML = "";

        // 1) Classification
        controls.appendChild(makeSelect({
          id: "classificationSelect",
          label: "CLASSIFICATION",
          options: DATA.classifications,
          placeholder: "Select classification…",
          value: state.classification,
          onChange: (val) => {
            state.classification = val;
            clearBelow(["creature", "variant", "location", "atmosphere", "camera"]);
            renderControls();
            renderPrompt();
          }
        }));

        // 2) Creature
        if (state.classification) {
          const creatureOptions = DATA.creatures[state.classification] || [];
          controls.appendChild(makeSelect({
            id: "creatureSelect",
            label: "CREATURE",
            options: creatureOptions,
            placeholder: "Select creature…",
            value: state.creature,
            onChange: (val) => {
              state.creature = val;
              clearBelow(["variant", "location", "atmosphere", "camera"]);
              renderControls();
              renderPrompt();
            }
          }));
        }

        // 3) Variant (optional)
        const variantOptions = state.creature ? (DATA.variants[state.creature] || []) : [];
        if (state.creature && variantOptions.length) {
          controls.appendChild(makeSelect({
            id: "variantSelect",
            label: "VARIANT",
            options: variantOptions,
            placeholder: "Select variant…",
            value: state.variant,
            onChange: (val) => {
              state.variant = val;
              renderPrompt();
            }
          }));
        }

        // 4) Location, 5) Atmosphere, 6) Camera (only after creature chosen)
        if (state.creature) {
          controls.appendChild(makeSelect({
            id: "locationSelect",
            label: "LOCATION",
            options: DATA.locations,
            placeholder: "Select location…",
            value: state.location,
            onChange: (val) => {
              state.location = val;
              renderPrompt();
            }
          }));

          controls.appendChild(makeSelect({
            id: "atmosphereSelect",
            label: "ATMOSPHERE",
            options: DATA.atmospheres,
            placeholder: "Select atmosphere…",
            value: state.atmosphere,
            onChange: (val) => {
              state.atmosphere = val;
              renderPrompt();
            }
          }));

          controls.appendChild(makeSelect({
            id: "cameraSelect",
            label: "CAPTURE TYPE",
            options: DATA.cameras,
            placeholder: "Select capture type…",
            value: state.camera,
            onChange: (val) => {
              state.camera = val;
              renderPrompt();
            }
          }));
        }
      }

      function renderPrompt() {
        const parts = [];

        // NAFO flavor base
        parts.push("NAFO FIELD REPORT STYLE");
        parts.push("classified archive aesthetic, officially denied");

        if (state.classification) {
          parts.push(`classification: ${labelFor(DATA.classifications, state.classification)}`);
        }

        if (state.creature) {
          const cList = DATA.creatures[state.classification] || [];
          parts.push(`subject: ${labelFor(cList, state.creature)}`);
        }

        if (state.variant) {
          parts.push(`variant: ${labelFor(DATA.variants[state.creature], state.variant)}`);
        }

        if (state.location) parts.push(`location: ${labelFor(DATA.locations, state.location)}`);
        if (state.atmosphere) parts.push(`atmosphere: ${labelFor(DATA.atmospheres, state.atmosphere)}`);
        if (state.camera) parts.push(`capture: ${labelFor(DATA.cameras, state.camera)}`);

        // Subtle “CRT archive” cues (no nightclub flicker)
        parts.push("subtle scanlines, low contrast, archival grain, timeworn documentation, restrained horror");

        finalPrompt.value = parts.join(", ");
      }

      async function copyPrompt() {
        copyHint.textContent = "";
        const text = finalPrompt.value;

        try {
          await navigator.clipboard.writeText(text);
          copyHint.textContent = "Copied to clipboard.";
        } catch (e) {
          // Fallback
          finalPrompt.focus();
          finalPrompt.select();
          document.execCommand("copy");
          copyHint.textContent = "Copied (fallback).";
        }

        setTimeout(() => (copyHint.textContent = ""), 1400);
      }

      function resetAll() {
        state.classification = "";
        state.creature = "";
        state.variant = "";
        state.location = "";
        state.atmosphere = "";
        state.camera = "";
        copyHint.textContent = "";
        renderControls();
        renderPrompt();
      }

      copyBtn.addEventListener("click", copyPrompt);
      resetBtn.addEventListener("click", resetAll);

      // Init
      renderControls();
      renderPrompt();
    })();
  </script>
</body>
</html>
